\chapter{Etat de l'Art}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Présentation de l'ESP}
    \textbf{Aperçu}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.3]{images/esp32-devkitc.jpg}
        \caption{ESP32-DevKitC V4 with ESP32-WROOM-32 module
            \cite{esp32-gettingStarted}}
        \label{esp32_img}
    \end{figure}
    Comme dit plus haut, les noeuds de notre réseau sont des \esp.
    Pour ce projet, nous utilisons un kit de développement (Fig. \ref{esp32_img}) équipé d'un
    \esp\textsc{-wroom32}, développé par Espressif. L'\esp\textsc{-wroom32}
    un System-on-Chip (SoC), c'est à dire un circuit intégré rassemblant plusieurs
    composants comme des entrées/sorties, de la mémoire \textsc{ram}, micorprocesseurs,
    microcontrôleurs, etc.
    %todo prix
    Il a été choisi pour son faible coût (entre 3.50\euro\ et 4\euro) et sa conception adaptée à l'Internet des Objets (IoT). 
    En effet, en plus de supporter le \wifi\ et le Bluetooth 2.4GHz,
    sa consommation en énergie est faible et il possède des mécanismes permettant de l'économiser. %et il possède plusieurs modes de fonctionnement.
    %permettant de la réduire (voir Table \ref{Consumption_PowerModes}).
    La table \ref{spec} fournit ses spécifications.
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|}
            \hline
            \rowcolor{lightgray}
            Element & Spécification\\ \hline
            WiFi & 802.11 b/g/n (802.11n jusqu'à 150 Mbps)\\ \hline
            Bluetooth & Bluetooth v4.2 BR/EDR and BLE specification\\ \hline
            CPU & 2 micorprocesseurs Xtensa \up{\tiny{\textregistered}} 32-bit LX6\\ \hline
            Interfaces & \makecell{SD card, UART, SPI, SDIO, I2C, LED PWM, Motor PWM, I2S,IR, \\
                pulse counter, GPIO, capacitive touch sensor, ADC, DAC}\\ \hline
            \makecell{Tension de \\fonctionnement} & $3.0V \sim 3.6V$\\ \hline
        \end{tabular}
        \caption{Spécification de l'\esp\textsc{-wroom32} \cite{esp32-WROOM-32-datasheet}}
        \label{spec}
    \end{table}
    \textbf{Schéma-bloc}
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.15]{images/esp32-blockDiagram.png}
        \caption{Schéma-bloc \cite{esp32-datasheet}}
        %\label{}
    \end{figure}

    \textbf{Mémoire}\cite{esp32-WROOM-32-datasheet}\\
        La mémoire interne inclut:
        \begin{itemize}
            \item 448 KB de ROM pour le démarrage et les fonctions de base
            \item 520 KB de SRAM pour les données et les instructions
        \end{itemize}
        L'\esp\ prend aussi en charge de la mémoire externe.\\
    
    
        \textbf{Gestion de l'énergie}\\
        Comme dit plus haut, l'\esp\ a une consommation d'énergie faible. De plus, il possède plusieurs
        modes de fonctionnement repris dans la Table \ref{Consumption_PowerModes}, permettant de
        la diminuer.
    
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|c|l|}
            \hline
            \rowcolor{lightgray}
            Power mode & Description & Power consumption\\\hline
            Active & radio and CPU are on  & 95mA $\sim$ 240 mA\\ \hline
            Modem-sleep & radio is off, CPU is on at 80MHz & 20mA $\sim$ 31mA\\ \hline
            Light-sleep & \makecell{CPU is paused, RTC memory and \\peripherals are running.\\
            Any wake-up events like \mac\ events will \\wake
            up the chip.} & 0.8mA\\ \hline
            Deep-sleep & RTC memory and RTC peripherals are powered on & $10\mu A\sim 150\mu A$\\ \hline
            Hibernation & RTC timer only & $5\mu A$\\ \hline
            Power off & - & $0.1 \mu A$\\ \hline
        \end{tabular}
        \caption{Consommation par mode \cite{esp32-datasheet}}
        \label{Consumption_PowerModes}
        
    \end{table}





    %L'\esp\ est un système embarqué développé par Espressif et dédié à l'internet
    %des objets.\\
    %Il est compatible WiFi et Bluetooth 2.4 GHz. Il a une consommation faible
    %en énergie et des mécanismes d'économies d'énergie.\\
    %Il est équipé de 34 pins GPIOs, d'un CPU Xtensa \up{\tiny{\textregistered}}
    %single-/dual-core 32-bit LX6
    %\begin{figure}[H]
    %    \centering
    %    \includegraphics[scale=0.4]{images/esp32-devkitc.jpg}
    %    \caption{ESP32-DevKitC V4 with ESP32-WROOM-32 module
    %        \cite{esp32-gettingStarted_w}}
    %    \label{esp32_img}
    %\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Environnement de développement}
    Trois environnements s'offrent à nous:
    \begin{enumerate}
        \item \textbf{MicroPython}\cite{micropython}\\
            Selon le site officiel de MicroPython, MicroPython
            est une implémentation simple et efficace de Python 3 incluant un
            petit sous-ensemble de la bibliothèque standard Python. Il est
            optimisé pour fonctionner sur des microcontrôleurs, open source et facile à utiliser.
            La documentation est complète et de nombreux tutoriels sont disponible et facilement compréhensible.
            Cependant, MicroPython n'expose pas les fonctions de bas niveau utiles pour ce projet.
            Par exemple il semble difficile d'envoyer des paquets au niveau de la
            couche lisaison de données ou encore, d'avoir accès aux tables de routages \textsc{ip}.\\
            Voici un exemple illustrant la simplicité du langage. Cet exemple permet de faire clignoter
            une led branchée au \textsc{gpio} 23.
            \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,bgcolor=myGray,fontsize=\footnotesize, linenos]{python}
import machine
import time
led = machine.Pin(23, machine.Pin.OUT) #led configuration
while(TRUE):
    led.value(1) #led on
    time.sleep(1) # delay
    led.value(0) #led off
    time.sleep(2)
            \end{minted}
        
        \item \textbf{IoT Development Framework (IDF)}\cite{idf}\\
            IDF est l'environnement du constucteur de l'\esp\ (Espressif).
            La documentation est complète mais le code source n'est pas entièrement
            disponible. Pour certaines parties du framework, nous n'avons accès qu'aux
            fichiers d'entête.
            Ce framework est natif et nous apportera donc une plus grande fidélité à l'\esp.
            Cet environnement nous donne aussi accès à des fonctionnalités de FreeRTOS
            (free real-time operating system), un système d'exploitation temps
            réel open source pour microcontrôleurs. Ses fonctionnalités pourront nous être 
            utiles pour ce projet. 
            Des protocoles tel que \espmesh\ ou
            \espnow\ sont également disponible. Ils faciliteraient la mise en place d'un réseau \mesh.
            Voici un exemple de code permettant de faire clignoter une led.
            \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,bgcolor=myGray,fontsize=\footnotesize, linenos]{c}
            #include <stdio.h>
            #include "freertos/FreeRTOS.h"
            #include "freertos/task.h"
            #include "driver/gpio.h"
            #include "sdkconfig.h"

            #define BLINK_GPIO CONFIG_BLINK_GPIO
            
            void app_main(void)
            {
                /*Configure the IOMUX register for pad BLINK_GPIO*/
                gpio_pad_select_gpio(BLINK_GPIO);
                /* Set the GPIO as a push/pull output */
                gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
                while(1) {
                    /* Blink off (output low) */
                    printf("Turning off the LED\n");
                    gpio_set_level(BLINK_GPIO, 0);
                    vTaskDelay(1000 / portTICK_PERIOD_MS);
                    /* Blink on (output high) */
                printf("Turning on the LED\n");
                    gpio_set_level(BLINK_GPIO, 1);
                    vTaskDelay(1000 / portTICK_PERIOD_MS);
                }
            }
            \end{minted}
        \item \textbf{Arduino}\cite{aruino-esp32}\\
            L'environnement Arduino se base sur IDF. Il est donc possible que certaines
            fonctionnalités d'IDF ne soient pas disponible. 
            La documentation est moins complète qu'IDF mais tout le code source est disponible.
            Comme MicroPython, il semble difficile d'envoyer des paquets au niveau de la
            couche lisaison de données ou d'avoir accès aux tables de routages \textsc{ip}.\\
            \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,bgcolor=myGray,fontsize=\footnotesize, linenos]{c}
#define LED  2
 
 void setup() {
   pinMode(LED,OUTPUT);
 }
  
 void loop() {
   delay(1000);
   digitalWrite(LED,HIGH);
   delay(100);
   digitalWrite(LED,LOW);
 }

            \end{minted}
    \end{enumerate}
    \vspace{1cm}
    Notons que les solutions évoquées ci-dessus sont gratuites. Il existe des solutions
    commerciales payantes que nous n'avons pas évoqué car il est tout a fait possible de
    travailler avec des solutions gratuites.\\
    
    Nous choisirons IDF pour sa documentation complète, sa nativité et pour son ensemble
    de fonctionnalités plus exhaustif que les autres environnements. Néanmoins, 
    avec les extraits de code, nous remarquons qu'il sera plus difficile à prendre en mains.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Protocoles de routage}
    Dans cette section, nous discutons de différents protocoles de routage envisageables.
    Nous allons d'abord établir un classement des protocoles de routage \mesh.
    Ensuite nous allons décrire brièvement les protocoles les plus cités dans la littérature pour les classer
    en fonction de leur appartenance à une catégorie établie dans notre classement. 
    Enfin, nous allons choisir un protocole à implémenter pour ce projet.\\

    \underline{\textbf{Classification}}\\

    Les protocoles de routages \mesh\ peuvent être divisés en deux grandes catégories:
    \begin{enumerate}
        \item \textbf{Proactifs}: Les noeuds maintiennent une/des table(s) de routage
            qui stockent les routes vers tous les noeuds du réseau. 
            Ils envoient régulièrement des paquets de contrôle à travers le réseau pour échanger et 
            mettre à jour l'information de leurs voisins.
        \item \textbf{Réactifs}: Ces protocoles établissent une route uniquement quand des paquets
            doivent être transférés.
    \end{enumerate}
    Nous écartons les protocoles proactifs pour ce projet car ils gardent
    beaucoup d'information en mémoire. Ils ne passent donc pas à l'échelle.
    Les protocoles réactifs sont plus économes en ressources, mais nécessitent parfois un délai
    plus long pour établir une route, car elles sont établies à la demande.\\

    \underline{\textbf{Description}}\\

    Il existe une multitude de protocols de routage \mesh.
    Ci-dessous, en voici quelques-uns souvent cités dans la littérature:\\
    \begin{itemize}
        \item \textbf{AODV}\cite{rfc_aodv} Ad-hoc On-demand Distance Vector\\
            Protocole réactif à vecteur de distance que nous décrirons en détail par la suite.\\
        \item \textbf{DSR}\cite{rfc_dsr} Dynamic Source Routing\\
            Similaire à AODV mais ici, les paquets servant à la découverte d'un chemin
            (\textit{RREQ}) contiennent tous les sauts de ce chemin.\\
        \item \textbf{OLSR}\cite{rfc_olsr} Optimized Link State Routing\\
            Protocole proactif à état de liens. Dans ce protocole, certains noeuds servent de relais pour effectuer
            le broadcasting des paquets servant à la découverte de chemins. L'ensemble de ces noeuds forme un arbre couvrant du réseau.\\
        \item \textbf{B.A.T.M.A.N}\cite{batman} Better Approach to Mobile Adhoc Networking\\
            Protocole proactif à état de liens. Le protocole ne calcule
            pas le chemin pour atteindre un noeud mais le meilleur saut dans la bonne direction.
            Pour cela, pour chaque destination il va sélectionner son voisin qui lui a transmis
            le plus de messages de cette destination.\\
        \item \textbf{DSDV}\cite{dsdv} Destination Sequence Distance Vector\\
            Protocole à vecteur de distance basé sur l'algorithme de Bellman-Ford.
    \end{itemize}

    Nous pouvons donc classer ces protocoles de la manière suivante: 
    \begin{diagram}[H]
        \Tree[.{wireless network protocols} 
            [.Reactive [.\textsc{aodv} ]
                [.\textsc{dsr} ]]
            [.Proactive [.{Link-state} 
                [.\textsc{olsr} ] 
                [.\textsc{b.a.t.m.a.n} ]] 
                [.{Distance-vector} [.\textsc{dsdv} ]]]]
        \caption{Classifications des protocols de routage }
    \end{diagram}

    \underline{\textbf{Choix d'un protocole}}\\

    Comme dit plus haut, nous écartons les protocoles proactifs. Il nous reste donc le choix entre \aodv\ et \textsc{dsr}.
    Nous allons retenir \aodv\ pour la taille fixe de ses paquets. En effet, \textsc{dsr} utilise plus de données quand
    les routes contiennent un grand nombre de sauts.

    
    
%    Dans cette section nous discutons de différents protocoles de routage envisageables.\\
%    Tout d'abord, nous établirons un classement des différents types de protocoles de routage\mesh. \\
%    Ensuite, nous etudierons et comparerons différents protocoles de routage mesh: \espmesh\
%    \cite{esp-mesh_w}, OLSR\cite{olsr_w}, AODV\cite{aodv_w} et DSR\cite{dsr_w}\\
%    Enfin nous allons choisir un protocole à implémenter sur \esp.\\
%    
%    \subsection{Classification}
%    Les protocoles de routages \mesh\ peuvent être divisés en deux grandes catégories:
%    \begin{enumerate}
%        \item \textbf{Proactifs}: Les noeuds maintiennent une/des table(s) de routage
%            qui stockent les routes vers tous les noeuds du réseau. 
%            Ils envoient régulièrement des paquets de contrôle à travers le réseau pour échanger et 
%            mettre à jour l'information de leurs voisins.
%        \item \textbf{Réactifs}: Ces protocoles établissent une route uniquement quand des paquets
%            doivent être transférés.
%    \end{enumerate}
%    Nous écarterons les protocoles proactifs pour ce projet car ils gardent
%    beaucoup d'information en mémoire. Ils ne passent donc pas à l'échelle.\\
%    Les protocoles réactifs sont plus économes en ressources mais nécessitent parfois un délai
%    plus long pour établir une route
%    car elles sont établies à la demande.\\
%    
%    Il existe une multitude de protocols de routage \mesh. 
%    Ci-dessous, en voici quelques-uns souvent cités dans la littérature:\\
%    \begin{itemize}
%        \item \textbf{AODV}\cite{aodv_w} Ad-hoc On-demand Distance Vector\\
%            Protocole réactif à vecteur de distance que nous décrirons en détail par la suite.\\
%        \item \textbf{DSR}\cite{dsr_w} Dynamic Source Routing\\
%            Similaire à AODV mais ici, les paquets servant à la découverte d'un chemin
%            (\textit{RREQ}) contiennent tous les sauts de ce chemin.\\
%        \item \textbf{OLSR}\cite{olsr_w} Optimized Link State Routing\\
%            Protocole proactif à état de liens. Dans ce protocole, certains noeuds servent de relais pour effectuer
%            le broadcasting des paquets servant à la découverte de chemins. L'ensemble de ces noeuds forme un arbre couvrant du réseau.\\
%        \item \textbf{B.A.T.M.A.N}\cite{batman_w} Better Approach to Mobile Adhoc Networking\\
%            Protocole proactif à état de liens. Le protocole ne calcule
%            pas le chemin pour atteindre un noeud mais le meilleur saut dans la bonne direction.
%            Pour cela, pour chaque destination il va sélectionner son voisin qui lui a transmis
%            le plus de messages de cette destination.\\
%        \item \textbf{DSDV}\cite{dsdv_w} Destination Sequence Distance Vector\\
%            Protocole à vecteur de distance basé sur l'algorithme de Bellman-Ford.
%    \end{itemize}
%    On peut donc classer ces protocoles de la manière suivante: 
%    \begin{diagram}[H]
%        \Tree[.{wireless network protocols} 
%            [.Reactive [.\textsc{aodv} ]
%                [.\textsc{dsr} ]]
%            [.Proactive [.{Link-state} 
%                [.\textsc{olsr} ] 
%                [.\textsc{b.a.t.m.a.n} ]] 
%                [.{Distance-vector} [.\textsc{dsdv} ]]]]
%        \caption{Classifications des protocols de routage }
%    \end{diagram}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\input{s_espMesh.tex}    
%    \vspace{1cm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%\newpage 
%\input{s_aodv.tex}